#!/usr/bin/env python3
import rospy
from geometry_msgs.msg import Twist

import rospy
import tf2_ros
import tf2_geometry_msgs
from geometry_msgs.msg import PoseStamped


class Pid:
    def __init__(self, kp=5.0, ki=0.0, kd=0.0):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.prev_error = 0.0
        self.integral = 0.0

    def output(self, error):
        self.integral += error
        self.derivative = error - self.prev_error
        control_output = self.kp * error + self.ki * \
            self.integral + self.kd * self.derivative
        self.prev_error = control_output
        return control_output


rospy.init_node('aruco_marker_offset')

tf_buffer = tf2_ros.Buffer()
tf_listener = tf2_ros.TransformListener(tf_buffer)

aruco_marker_frame = 'fiducial_11'
base_frame = 'camera_link'

pub = rospy.Publisher('/tello/cmd_vel', Twist, queue_size=10)

pid_x = Pid()
pid_y = Pid()
pid_z = Pid(1.0, 0.0, 0.0)

while not rospy.is_shutdown():
    try:
        # Get the transform from the base frame to the ArUco marker frame
        transform = tf_buffer.lookup_transform(
            base_frame, aruco_marker_frame, rospy.Time.now(), rospy.Duration(0, 200000000))

        # Convert the transform to a PoseStamped message for easy manipulation
        pose = tf2_geometry_msgs.do_transform_pose(PoseStamped(), transform)

        # Extract the x, y, z offsets from the pose
        x_offset = pose.pose.position.x
        y_offset = pose.pose.position.y
        z_offset = pose.pose.position.z-0.5

        # Print the offsets
        rospy.loginfo('ArUco marker offset from base frame: x={}, y={}, z={}'.format(
            x_offset, y_offset, z_offset))

        # Calculate error
        error_x = x_offset
        error_y = y_offset
        error_z = z_offset

        # Calculate control output with PID formula
        control_output_x = pid_x.output(error_x)
        control_output_y = pid_y.output(error_y)
        control_output_z = pid_z.output(error_z)

        # Create Twist message with control output
        twist = Twist()

        twist.angular.z = control_output_x
        twist.linear.z = -control_output_y
        twist.linear.x = control_output_z

        # Set limits on the control output
        limit = 1000000000000.0
        twist.angular.z = max(min(twist.angular.z, limit), -limit)
        twist.linear.z = max(min(twist.linear.z, limit), -limit)
        twist.linear.x = max(min(twist.linear.x, limit), -limit)

        # Publish the Twist message
        pub.publish(twist)

    except:
        print('hello')
        pub.publish(Twist())
        continue
