#!/usr/bin/env python3
import rospy
from geometry_msgs.msg import Twist

import rospy
import tf2_ros
import tf2_geometry_msgs
from geometry_msgs.msg import PoseStamped, Vector3


class Pid:
    def __init__(self, kp=2.0, ki=0.05, kd=0.15):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.prev_error = 0.0
        self.integral = 0.0
        self.dt = 0.0  # iteration time

    def output(self, error):
        self.integral += error * self.dt
        self.derivative = (error - self.prev_error) / self.dt
        control_output = self.kp * error + self.ki * \
            self.integral + self.kd * self.derivative
        self.prev_error = error
        return control_output

    def reset_error(self):
        self.dt=0.0
        self.prev_error = 0.0
        self.integral = 0.0


rospy.init_node('aruco_marker_offset')

tf_buffer = tf2_ros.Buffer()
tf_listener = tf2_ros.TransformListener(tf_buffer)

aruco_marker_frame = 'fiducial_14'
target_frame = 'target'
base_frame = 'camera_link'

pub = rospy.Publisher('/tello/cmd_vel', Twist, queue_size=10)

pub_offset = rospy.Publisher('/tello/offset', Vector3, queue_size=10)

pid_x = Pid()
pid_y = Pid()
pid_z = Pid()

pid_yaw = Pid(5.0, 0.05, 0.05)

prev_time = rospy.get_time()

while not rospy.is_shutdown():
    try:
        # Get the transform from the base frame to the ArUco marker frame
        transform_target = tf_buffer.lookup_transform(
            base_frame, target_frame, rospy.Time.now(), rospy.Duration(0, 100000000))

        transform = tf_buffer.lookup_transform(
            base_frame, aruco_marker_frame, rospy.Time.now(), rospy.Duration(0, 100000000))

        # Convert the transform to a PoseStamped message for easy manipulation
        pose_target = tf2_geometry_msgs.do_transform_pose(
            PoseStamped(), transform_target)

        pose = tf2_geometry_msgs.do_transform_pose(
            PoseStamped(), transform)

        # Extract the x, y, z offsets from the pose
        x_offset = pose_target.pose.position.x
        y_offset = pose_target.pose.position.y
        z_offset = pose_target.pose.position.z

        yaw_offset = pose.pose.position.x

    except:
        rospy.logwarn("Waiting for '{}' tf.".format(target_frame))
        x_offset = 0
        y_offset = 0
        z_offset = 0
        yaw_offset = 0

        pid_x.reset_error()
        pid_y.reset_error()
        pid_z.reset_error()
        pid_yaw.reset_error()

    # Print the offsets
    rospy.loginfo('ArUco marker offset from base frame: x={}, y={}, z={}'.format(
        x_offset, y_offset, z_offset))

    # Calculate error
    error_x = x_offset
    error_y = y_offset
    error_z = z_offset

    error_yaw = yaw_offset

    # Set iteration time (dt)
    pid_x.dt = pid_y.dt = pid_z.dt = pid_yaw.dt = rospy.get_time() - prev_time

    # Calculate control output with PID formula
    control_output_x = pid_x.output(error_x)
    control_output_y = pid_y.output(error_y)
    control_output_z = pid_z.output(error_z)

    control_output_yaw = pid_yaw.output(error_yaw)

    # Create Twist message with control output
    twist = Twist()

    twist.linear.x = control_output_z
    twist.linear.y = -control_output_x
    twist.linear.z = -control_output_y

    twist.angular.z = control_output_yaw

    # Set limits on the control output
    limit = 1000000000000.0
    twist.linear.x = max(min(twist.linear.x, limit), -limit)
    twist.linear.y = max(min(twist.linear.y, limit), -limit)
    twist.linear.z = max(min(twist.linear.z, limit), -limit)

    offset_value = Vector3()

    offset_value.x = error_x
    offset_value.y = error_y
    offset_value.z = error_z

    pub_offset.publish(offset_value)

    # twist.angular.z = max(min(twist.angular.z, limit), -limit)

    prev_time = rospy.get_time()

    # Publish the Twist message
    pub.publish(twist)
